//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/ReferenceManager.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/lang/IllegalStateException.h"
#include "java/util/List.h"
#include "java/util/concurrent/CopyOnWriteArrayList.h"
#include "java/util/concurrent/locks/Lock.h"
#include "java/util/concurrent/locks/ReentrantLock.h"
#include "org/apache/lucene/search/ReferenceManager.h"
#include "org/apache/lucene/store/AlreadyClosedException.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface OrgApacheLuceneSearchReferenceManager () {
 @public
  id<JavaUtilConcurrentLocksLock> refreshLock_;
  id<JavaUtilList> refreshListeners_;
}

- (void)ensureOpen;

- (void)swapReferenceWithId:(id)newReference;

@end

J2OBJC_FIELD_SETTER(OrgApacheLuceneSearchReferenceManager, refreshLock_, id<JavaUtilConcurrentLocksLock>)
J2OBJC_FIELD_SETTER(OrgApacheLuceneSearchReferenceManager, refreshListeners_, id<JavaUtilList>)

static NSString *OrgApacheLuceneSearchReferenceManager_REFERENCE_MANAGER_IS_CLOSED_MSG_ = @"this ReferenceManager is closed";
J2OBJC_STATIC_FIELD_GETTER(OrgApacheLuceneSearchReferenceManager, REFERENCE_MANAGER_IS_CLOSED_MSG_, NSString *)

__attribute__((unused)) static void OrgApacheLuceneSearchReferenceManager_ensureOpen(OrgApacheLuceneSearchReferenceManager *self);

__attribute__((unused)) static void OrgApacheLuceneSearchReferenceManager_swapReferenceWithId_(OrgApacheLuceneSearchReferenceManager *self, id newReference);

__attribute__((unused)) static void OrgApacheLuceneSearchReferenceManager_release__WithId_(OrgApacheLuceneSearchReferenceManager *self, id reference);

@interface OrgApacheLuceneSearchReferenceManager_RefreshListener : NSObject

@end

@implementation OrgApacheLuceneSearchReferenceManager

- (void)ensureOpen {
  OrgApacheLuceneSearchReferenceManager_ensureOpen(self);
}

- (void)swapReferenceWithId:(id)newReference {
  OrgApacheLuceneSearchReferenceManager_swapReferenceWithId_(self, newReference);
}

- (void)decRefWithId:(id)reference {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (jboolean)tryIncRefWithId:(id)reference {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)acquire {
  id ref;
  do {
    if ((ref = JreLoadVolatileId(&current_)) == nil) {
      @throw [new_OrgApacheLuceneStoreAlreadyClosedException_initWithNSString_(OrgApacheLuceneSearchReferenceManager_REFERENCE_MANAGER_IS_CLOSED_MSG_) autorelease];
    }
    if ([self tryIncRefWithId:ref]) {
      return ref;
    }
    if ([self getRefCountWithId:ref] == 0 && JreLoadVolatileId(&current_) == ref) {
      JreAssert((ref != nil), (@"org/apache/lucene/search/ReferenceManager.java:104 condition failed: assert ref != null;"));
      @throw [new_JavaLangIllegalStateException_initWithNSString_(@"The managed reference has already closed - this is likely a bug when the reference count is modified outside of the ReferenceManager") autorelease];
    }
  }
  while (YES);
}

- (void)close {
  @synchronized(self) {
    if (JreLoadVolatileId(&current_) != nil) {
      OrgApacheLuceneSearchReferenceManager_swapReferenceWithId_(self, nil);
      [self afterClose];
    }
  }
}

- (jint)getRefCountWithId:(id)reference {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)afterClose {
}

- (void)release__WithId:(id)reference {
  OrgApacheLuceneSearchReferenceManager_release__WithId_(self, reference);
}

- (instancetype)init {
  OrgApacheLuceneSearchReferenceManager_init(self);
  return self;
}

- (void)dealloc {
  JreReleaseVolatile(&current_);
  RELEASE_(refreshLock_);
  RELEASE_(refreshListeners_);
  [super dealloc];
}

- (void)__javaClone {
  [super __javaClone];
  JreRetainVolatile(&current_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "ensureOpen", NULL, "V", 0x2, NULL, NULL },
    { "swapReferenceWithId:", "swapReference", "V", 0x22, "Ljava.io.IOException;", "(TG;)V" },
    { "decRefWithId:", "decRef", "V", 0x404, "Ljava.io.IOException;", "(TG;)V" },
    { "tryIncRefWithId:", "tryIncRef", "Z", 0x404, "Ljava.io.IOException;", "(TG;)Z" },
    { "acquire", NULL, "TG;", 0x11, "Ljava.io.IOException;", "()TG;" },
    { "close", NULL, "V", 0x31, "Ljava.io.IOException;", NULL },
    { "getRefCountWithId:", "getRefCount", "I", 0x404, NULL, "(TG;)I" },
    { "afterClose", NULL, "V", 0x4, "Ljava.io.IOException;", NULL },
    { "release__WithId:", "release", "V", 0x11, "Ljava.io.IOException;", "(TG;)V" },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "REFERENCE_MANAGER_IS_CLOSED_MSG_", NULL, 0x1a, "Ljava.lang.String;", &OrgApacheLuceneSearchReferenceManager_REFERENCE_MANAGER_IS_CLOSED_MSG_, NULL, .constantValue.asLong = 0 },
    { "current_", NULL, 0x44, "TG;", NULL, "TG;", .constantValue.asLong = 0 },
    { "refreshLock_", NULL, 0x12, "Ljava.util.concurrent.locks.Lock;", NULL, NULL, .constantValue.asLong = 0 },
    { "refreshListeners_", NULL, 0x12, "Ljava.util.List;", NULL, "Ljava/util/List<Lorg/apache/lucene/search/ReferenceManager$RefreshListener;>;", .constantValue.asLong = 0 },
  };
  static const char *inner_classes[] = {"Lorg.apache.lucene.search.ReferenceManager$RefreshListener;"};
  static const J2ObjcClassInfo _OrgApacheLuceneSearchReferenceManager = { 2, "ReferenceManager", "org.apache.lucene.search", NULL, 0x401, 10, methods, 4, fields, 0, NULL, 1, inner_classes, NULL, "<G:Ljava/lang/Object;>Ljava/lang/Object;Ljava/io/Closeable;" };
  return &_OrgApacheLuceneSearchReferenceManager;
}

@end

void OrgApacheLuceneSearchReferenceManager_ensureOpen(OrgApacheLuceneSearchReferenceManager *self) {
  if (JreLoadVolatileId(&self->current_) == nil) {
    @throw [new_OrgApacheLuceneStoreAlreadyClosedException_initWithNSString_(OrgApacheLuceneSearchReferenceManager_REFERENCE_MANAGER_IS_CLOSED_MSG_) autorelease];
  }
}

void OrgApacheLuceneSearchReferenceManager_swapReferenceWithId_(OrgApacheLuceneSearchReferenceManager *self, id newReference) {
  @synchronized(self) {
    OrgApacheLuceneSearchReferenceManager_ensureOpen(self);
    id oldReference = JreLoadVolatileId(&self->current_);
    JreVolatileStrongAssign(&self->current_, newReference);
    OrgApacheLuceneSearchReferenceManager_release__WithId_(self, oldReference);
  }
}

void OrgApacheLuceneSearchReferenceManager_release__WithId_(OrgApacheLuceneSearchReferenceManager *self, id reference) {
  JreAssert((reference != nil), (@"org/apache/lucene/search/ReferenceManager.java:273 condition failed: assert reference != null;"));
  [self decRefWithId:reference];
}

void OrgApacheLuceneSearchReferenceManager_init(OrgApacheLuceneSearchReferenceManager *self) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->refreshLock_, new_JavaUtilConcurrentLocksReentrantLock_init());
  JreStrongAssignAndConsume(&self->refreshListeners_, new_JavaUtilConcurrentCopyOnWriteArrayList_init());
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneSearchReferenceManager)

@implementation OrgApacheLuceneSearchReferenceManager_RefreshListener

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcClassInfo _OrgApacheLuceneSearchReferenceManager_RefreshListener = { 2, "RefreshListener", "org.apache.lucene.search", "ReferenceManager", 0x609, 0, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheLuceneSearchReferenceManager_RefreshListener;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(OrgApacheLuceneSearchReferenceManager_RefreshListener)
